<!DOCTYPE HTML>
<html>
	 
	<head>
		<link rel="icon" type="image/png" href="images/logo.png">
		<title>Thuy Nguyen</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<style>
* {
	box-sizing: border-box;
}

html,
body {
	margin: 0;
	min-height: 100vh;
	overflow-x: hidden;
	touch-action: none;
}

canvas {
	width: 100%;
	min-height: 101vh;
	object-fit:fill;
	
}

.control {
	display: grid;
	place-content: center;
	position: absolute;
	width: 100%;
	height: 100%;
	inset: 0;
	margin: 0;
}

.control_label {
	opacity: 0;
	display: grid;
	place-content: center;
	transition: opacity 1200ms cubic-bezier(0.075, 0.82, 0.165, 1);
}
.control.initial {
	height: 100%;
}
.control.initial .control_label {
	opacity: 1;
	
}

.control:hover .control_label {
	opacity: 1;
}

.control_display,
.control_input {
	grid-row: 1/-1;
	grid-column: 1/-1;
	position: relative;
	cursor: pointer;
}

.control_display {
	display: grid;
	place-content: center;
	font-size: 0.825em;
	font-weight: 500;
}


		</style>
		<style>
				.menu-container {
				width: 100%;
				height: 100%;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				position: absolute;
				z-index: 1;

				}
				.text {
				font-size: 10vw;
				letter-spacing: -.01em;
				line-height: 100%;
				margin: 0;
				
				width: 100%;
				color: rgba(182, 182, 182, 0.363);
				background: linear-gradient(to right, #ffffff, #f584ff) no-repeat;
				-webkit-background-clip: text;
				background-clip: text;
				background-size: 0%;
				transition: background-size cubic-bezier(.1,.5,.5,1) 0.5s;
				

				border-bottom: 1px solid #69666671;
				
				display: flex;
				flex-direction: column;
				align-items: flex-start;
				justify-content: center;
				position: relative;
				}

				span {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: #d1449b;
				color: #0D0D0D;
				
				clip-path: polygon(0 50%, 100% 50%, 100% 50%, 0 50%);
				transform-origin: center;
				transition: all cubic-bezier(.1,.5,.5,1) 0.4s;
				
				display: flex;
				flex-direction: column;
				justify-content: center;
				}

				.text:hover > span {
				clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
				}

				a {
				text-decoration: none;
				color: inherit;
				}
				@import url(https://fonts.googleapis.com/css?family=Anonymous+Pro);

				.cursor {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				font-size: 48px;
				font-weight: bold;
				color: #ffffff;
				text-align: center;
				white-space: normal;
				overflow: hidden;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
				}
				
				/* Animation */
				.typewriter-animation {
				animation: 
					fadeIn 1s ease-in,
					typewriter 4s steps(40) 1s 1 normal both,
					blinkingCursor 500ms steps(40) infinite normal,
					colorChange 6s alternate infinite;
				}
				
				@keyframes fadeIn {
				from { opacity: 0; }
				to { opacity: 1; }
				}
				
				@keyframes typewriter {
				from { width: 0; }
				to { width: 100%; }
				}
				
				@keyframes blinkingCursor {
				from { border-right-color: rgba(255, 255, 255, 0.75); }
				to { border-right-color: transparent; }
				}
				
				@keyframes colorChange {
				0% {
					color: #f584e6;
					letter-spacing: normal;
				}
				50% {
					color: #8bd0ff;
					letter-spacing: 5px;
				}
				100% {
					color: #f584e6;
					letter-spacing: normal;
				}
				}


				
				.scroll-down-icon {
				position: absolute;
				bottom: 20px;
				left: 50%;
				transform: translateX(-50%);
				color: #ffdef2b2;
				font-size: 24px;
				animation: bounceArrow 0.5s infinite alternate;
				z-index: 1;
				}

				@keyframes bounceArrow {
				from { transform: translateX(-50%) translateY(0); }
				to { transform: translateX(-50%) translateY(10px); }
				}

				
  		</style>
		<style>
					@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap");

						:root {
						--bg: #000000;
						--clr-1: #00c2ff;
						--clr-2: #33ff8c;
						--clr-3: #ffc640;
						--clr-4: #e54cff;
						
						--blur: 1rem;
						--fs: clamp(3rem, 8vw, 7rem);
						--ls: clamp(-1.95px, -0.75vw, -3.5px);
						}
						
						body {
						
						place-items: center;
						background-color: var(--bg);
						color: #fff;
						font-family: "Inter", "Poppins", Arial, sans-serif;
						}
						
						*,
						*::before,
						*::after {
						font-family: inherit;
						box-sizing: border-box;
						}
						
						.content {
						text-align: center;
						}
						
						.title {
								top: 50%;
								display: grid;
								position: absolute;
								white-space: nowrap;
								transform: translate(-50%, -50%);
								overflow: hidden;
								color: transparent;
								-webkit-text-fill-color: transparent; /* Safari */
								-webkit-text-stroke: 0.1rem rgb(255, 162, 206); /* Safari */
								text-shadow: 0px 0px 10px rgba(26, 16, 20, 0.7); /* Add the shadow effect */
								animation: textStrokeAnimation 5s infinite;
							}

							@keyframes textStrokeAnimation {
								0% {
									letter-spacing: -1vw;
									font-size: 8vw;
								}
								50% {
									letter-spacing: 1vw;
									font-size: 11vw;
								}
								100% {
									letter-spacing: -1vw;
									font-size: 8vw;
									
								}
							}

								.subtitle1 {
							place-items: center;
							text-align: center;
							position: relative;
							font: "Poppins";
							font-size: 0.6rem;
							text-transform: uppercase;
							letter-spacing: 0.5vw;
							top: 33vh;
							color: #ffd6eeec;
						}
								


		</style>

	</head>

	<body>
		<div class="preloader">
			<img src="images/me.gif" alt="">
		</div>


		<div height="100%" margin="0" style="background-image: url('images/bg.gif');">
			<canvas id="canvas"></canvas>
			<div class="control initial">
				<label class="control_label">
					<input type="checkbox"  name="vol" id="play" />
					<div class="control_display">
						
					</div>
				</label>
			
					<h1 class="cursor title" style="text-shadow: none;"> thuy nguyen </h1>
					<p class="subtitle1 "> Republic's Investor • Data Analyst • Digital Partnerships  </p>
					<div id="clock"></div>

				<div class="scroll-down-icon">
				<a href="#mn" class="fas fa-chevron-down"></a>
				</div>						
			</div>
		</div>

		<!-- Menu -->
		<div id="mn" class="menu-container" style="background-image: url('images/bg.gif')">
			<h1 class="text">about<span><a href="about.html">WOAH</a></span></h1>
			<h1 class="text">Projects<span><a href="projects.html">Analytics by Thuy</a></span></h1>
			<h1 class="text">CV<span><a href="CV.html">Full-time Exp.</a></span></h1>
			<h1 class="text">LIKE THIS?<span><a href="contact.html">LET'S CONNECT</a></span></h1>
		</div>
	
<!-- script -->
		<script>// Smooth scroll function
			// Smooth scroll function with fading effect
			function smoothScrollWithFade(target, duration) {
			const targetElement = document.querySelector(target);
			if (!targetElement) return;
		
			const targetPosition = targetElement.getBoundingClientRect().top + window.scrollY;
			const startPosition = window.scrollY;
			const distance = targetPosition - startPosition;
			let startTime = null;
		
			function scrollAnimation(currentTime) {
				if (startTime === null) startTime = currentTime;
				const timeElapsed = currentTime - startTime;
				const scrollAmount = easeInOutQuad(timeElapsed, startPosition, distance, duration);
				window.scrollTo(0, scrollAmount);
		
				const opacity = Math.min(1, timeElapsed / duration);
				targetElement.style.opacity = opacity;
		
				if (timeElapsed < duration) requestAnimationFrame(scrollAnimation);
			}
		
			// Easing function for smooth scroll
			function easeInOutQuad(t, b, c, d) {
				t /= d / 2;
				if (t < 1) return c / 2 * t * t + b;
				t--;
				return -c / 2 * (t * (t - 2) - 1) + b;
			}
		
			requestAnimationFrame(scrollAnimation);
			}
		
			// Add click event listener to the icon
			const scrollIcon = document.querySelector('.scroll-down-icon a');
			scrollIcon.addEventListener('click', function (event) {
			event.preventDefault();
			smoothScrollWithFade(this.getAttribute('href'), 1000); // Adjust duration as needed
			});
		</script>
		<script>
		const cursor = document.querySelector(".cb-cursor");
			window.onpointermove = event => {
				const { clientX, clientY } = event;
				cursor.animate({
					left: `${clientX}px`,
					top: `${clientY}px`
				}, { duration: 3000, fill: "forwards" })
			}
			const elements = [...document.querySelectorAll("h2 div")]
			elements.map(element => {
				element.onmouseover = () => {
					cursor.classList.add("-video")
				}
				element.onmouseout = () => {
					cursor.classList.remove("-video")
				}
			})
		</script>
		<script>

const canvas = window.canvas;
const gl = canvas.getContext("webgl2");
const dpr = Math.max(0.5, 0.5 * window.devicePixelRatio);
/** @type {Map<string,PointerEvent>} */
const touches = new Map();

const vertexSource = `#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

in vec2 position;

void main(void) {
    gl_Position = vec4(position, 0., 1.);
}
`;
const fragmentSource = `#version 300 es
/*********
* made by Matthias Hurrle (@atzedent)
*/

#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

uniform float time;
uniform vec2 resolution;
uniform vec2 touch;
uniform int pointerCount;
uniform float brightness;

out vec4 fragColor;

#define T (1.0*time)
#define S smoothstep
#define mouse (touch/resolution)
#define LPOS (p-vec3(0,1.5,0))
#define rep(p,n) (mod(p,n)-.5*n)
#define syl(p,s) (length(p)-s)
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))

float rnd(float a) {
  return fract(sin(a*12.783)*78.7599);
}

float curve(float a, float b) {
  a /= b;

  return mix(
    rnd(floor(a)),
    rnd(floor(a)+1.),
    pow(S(.0, 1.,fract(a)), b)
  );
}

float box(vec3 p, vec3 s, float r) {
  p = abs(p)-s;

  return length(max(p,.0))+
  min(.0, max(max(p.x, p.y), p.z))-r;
}

float ftor(vec3 p, vec3 s, float r) {
  vec2 e = vec2(
    abs(length(p.xz)-s.x)-s.z,
    abs(p.y)-s.y
  );

  return length(max(e,.0))+
  min(.0, max(e.x, e.y))-r;
}

float disc(vec3 p, vec2 s, float r) {
  vec2 e = vec2(
    abs(length(p.xz)),
    abs(p.y)
  )-s;

  return length(max(e,.0))+
  min(.0, max(e.x, e.y))-r;
}

float oct(vec3 p, float s) {
  p = abs(p);

  return (p.x+p.y+p.z-s)*(1./sqrt(3.));
}

float mat = .0;
float map(vec3 p) {
  float d = 1e5,
  bx1 = box(p, vec3(.05,1,.05),.05),
  ft1 = ftor(LPOS, vec3(1,.5,.0125),.05),
  dc1 = disc(p+vec3(0, 1.125, 0), vec2(1,.125),.05),
  room = -(oct(p, 12.));

  d = min(d, bx1);
  d = min(d, min(ft1,length(LPOS)-.5));
  d = min(d, dc1);
  d = min(d, room);

  if (d == ft1) {
    mat = 1.;
  } else if (d == room) {
    mat = .2;
  } else mat = .0;

  return d;
}

vec3 norm(vec3 p) {
  vec2 e = vec2(1e-3, 0);
  float d = map(p);
  vec3 n = d-vec3(
    map(p-e.xyy),
    map(p-e.yxy),
    map(p-e.yyx)
  );

  return normalize(n);
}

float blur(float d, float k) {
  float blur = S(.5 - k, .5 + k, d);
  
  return blur;
}

float getao(vec3 p, vec3 n, float dist) {
  return clamp(map(p+n*dist)/dist, .0, 1.);
}

void cam(inout vec3 p) {
  if(pointerCount>0) {
    p.yz*=rot(mouse.y*acos(-1.)-acos(.0));
    p.xz*=rot(mouse.x*acos(-1.)*2.);
  } else {
    p.yz*=rot(sin(T*.5));
    p.xz*=rot(T*.25);
    p.xy*=rot(sin(T*.5)*.5);
  }
}

void main(void) {
  vec3 col = vec3(0);
  const float n=1.;

  for (float dx=.0; dx<n; dx++) {
  for (float dy=.0; dy<n; dy++) {
  vec2 coord=gl_FragCoord.xy+vec2(dx,dy)*.5,
  uv = (
    gl_FragCoord.xy-.5*resolution
  ) / min(resolution.x, resolution.y);

  vec3
  ro = vec3(0, 0, -exp(sin(T))-4.);
  vec3 rd = normalize(vec3(uv, .7)); 

  cam(ro);
  cam(rd);

  vec3 p = ro,
  l = normalize(ro-.1);


  const float steps = 160., maxd=100.;
  float i = .0,
  dd = .0,
  at = .0,
  side = 1., bnz = .0,
  e = .5;

  for (; i < steps; i++) {
    float d = map(p);

    if (d < 1e-3) {
      vec3 n = norm(p),
      lpos=ro-.1,
      l = normalize(lpos);
      if (mat == 1.) {
        if (dot(l, n) < .0) l = -l;
        float diff = max(.0, dot(n, l)),
        fres = max(.0, pow(S(.0, 1.,dot(-rd, n)), 7.)),
        fade=1./dot(LPOS,LPOS)+1./dot(p-lpos,p-lpos);
        col += diff*fres*fade;

        side = -side;
        
        vec3 rdo = refract(rd, n, 1.+side*.45);
        
        if (dot(rdo, rdo) == .0) {
          rdo = reflect(rd, n);
        }
        
        d = 9e-1;
        rd = rdo;

      } else {
        if (bnz++>2.) break;
        vec3 h = normalize(l-reflect(rd, n));
        float ao =
        (getao(p, n, 12.)*.5+.5)*
        (getao(p, n, 1.)*.3+.7)*
        (getao(p, n,.5)*1.+.0);

        float fog = 1.-pow(S(.0, 1.,dd/20.), 2.);
        col += pow(1.-abs(dot(n, rd)), 3.) * ao * vec3(0.5, 0.6, 1.0);

        col = mix(col, vec3(ao), blur(d, 1.5));
        rd=reflect(rd,n);
        d=3e-3;
      }
    }
    if (dd > maxd) {
      dd = maxd;
      break;
    }

    p += rd*d;
    dd += d;
    at += exp(-length(LPOS)*3.5);
  }

  col += vec3(1,.3,.5)*at;
  col *= brightness/n;
  }}
  
  fragColor = vec4(col, 1);
}
`;
let time;
let buffer;
let program;
let touch;
let resolution;
let pointerCount;
let brightness;
let vertices = [];
let touching = false;
let playbackRate = 0.25;

function resize() {
	const { innerWidth: width, innerHeight: height } = window;

	canvas.width = width * dpr;
	canvas.height = height * dpr;

	gl.viewport(0, 0, width * dpr, height * dpr);
}

function compile(shader, source) {
	gl.shaderSource(shader, source);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		console.error(gl.getShaderInfoLog(shader));
	}
}

function setup() {
	const vs = gl.createShader(gl.VERTEX_SHADER);
	const fs = gl.createShader(gl.FRAGMENT_SHADER);

	program = gl.createProgram();

	compile(vs, vertexSource);
	compile(fs, fragmentSource);

	gl.attachShader(program, vs);
	gl.attachShader(program, fs);
	gl.linkProgram(program);

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		console.error(gl.getProgramInfoLog(program));
	}

	vertices = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0];

	buffer = gl.createBuffer();

	gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

	const position = gl.getAttribLocation(program, "position");

	gl.enableVertexAttribArray(position);
	gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

	time = gl.getUniformLocation(program, "time");
	touch = gl.getUniformLocation(program, "touch");
	pointerCount = gl.getUniformLocation(program, "pointerCount");
	resolution = gl.getUniformLocation(program, "resolution");
	brightness = gl.getUniformLocation(program, "brightness");
}

let passedTime = 0;
function draw() {
	gl.clearColor(0, 0, 0, 1);
	gl.clear(gl.COLOR_BUFFER_BIT);

	gl.useProgram(program);
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

	const t = passedTime;
	gl.uniform1f(time, t);
	gl.uniform1f(brightness, playbackRate);
	gl.uniform2f(touch, ...getTouches());
	gl.uniform1i(pointerCount, touches.size);
	gl.uniform2f(resolution, canvas.width, canvas.height);
	gl.drawArrays(gl.TRIANGLES, 0, vertices.length * 0.5);
}

function getTouches() {
	if (!touches.size) {
		return [0, 0];
	}

	for (let [id, t] of touches) {
		const result = [dpr * t.clientX, dpr * (innerHeight - t.clientY)];

		return result;
	}
}

class Player {
	constructor(...urls) {
		this.idx = 0;
		this.urls = urls;
		this.audio = new Audio();
		this.audio.src = urls[this.idx];
		this.audio.crossOrigin = "anonymous";
		this.audio.loop = true;
		this.audio.preservesPitch = false;

		this.initialized = false;
	}
	setup() {
		this.audioCtx = new window.AudioContext();
		this.audioSource = this.audioCtx.createMediaElementSource(this.audio);
		this.audioSource.connect(this.audioCtx.destination);

		this.initialized = true;
	}
	next() {
		this.idx = (this.idx + 1) % this.urls.length;
		this.audio.src = this.urls[this.idx];
		this.audio.play();
	}
	resume() {
		this.audio.play();
	}
	pause() {
		this.audio.pause();
	}
	toggle() {
		if (this.audio.paused) {
			this.audio.play();
		} else {
			playbackRate = 0.25;
			this.audio.load();
		}
	}
	speedup(rate) {
		if (!this.audio.paused) {
			playbackRate = Math.max(0.25, Math.min(1, playbackRate + 0.001));
			this.audio.playbackRate = rate * playbackRate;
		}
	}
}

let player;
let then = 0;
let frames = 0;

function loop(now) {
	frames++;

	const elapsed = now - then;
	let rate = 1;

	if (elapsed > 1000) {
		const fps = frames / (elapsed / 1000);
		rate = Math.min(1, 60 / fps);
		then = now;
		frames = 0;
	}

	passedTime += 0.02 * rate * playbackRate;

	if (player) {
		player.speedup(rate);
	}

	draw(now);
	requestAnimationFrame(loop);
}

function init() {
	setup();
	resize();
	loop(0);

	// Start autoplay
	if (!player) {
		player = new Player("https://www.maz25.de/artifacts/lullaby.mp3");
		player.setup();
	}
	player.toggle();
}

document.body.onload = init;
window.onresize = resize;
canvas.onpointerdown = (e) => {
	touching = true;
	touches.set(e.pointerId, e);
};
canvas.onpointermove = (e) => {
	if (!touching) return;
	touches.set(e.pointerId, e);
};
canvas.onpointerup = (e) => {
	touching = false;
	touches.clear();
};
canvas.onpointerout = (e) => {
	touching = false;
	touches.clear();
};


		</script>
		<script src='https://unpkg.com/three@0.146.0/build/three.min.js'></script>
		<script src='https://unpkg.com/three@0.146.0/examples/js/postprocessing/EffectComposer.js'></script>
		<script src='https://unpkg.com/three@0.146.0/examples/js/postprocessing/ShaderPass.js'></script>
		<script src='https://unpkg.com/three@0.146.0/examples/js/shaders/CopyShader.js'></script>
		<script src='https://unpkg.com/three@0.146.0/examples/js/postprocessing/RenderPass.js'></script>
		<script src='https://unpkg.com/three@0.146.0/examples/js/shaders/LuminosityHighPassShader.js'></script>
		<script src='https://unpkg.com/three@0.146.0/examples/js/postprocessing/UnrealBloomPass.js'></script>
		<script src='https://unpkg.com/three@0.146.0/examples/js/objects/Reflector.js'></script>
		<script src="assets/js/jquery.min.js"></script>
		<script src="assets/js/jquery.scrollex.min.js"></script>
		<script src="assets/js/jquery.scrolly.min.js"></script>
		<script src="assets/js/browser.min.js"></script>
		<script src="assets/js/breakpoints.min.js"></script>
		<script src="assets/js/util.js"></script>
		<script src="assets/js/main.js"></script>
		
	</body>
</html>